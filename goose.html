<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
        <!-- Favicon for different browsers and devices -->
        <link rel="icon" type="image/svg+xml" href="favicon.svg" />
        <link rel="icon" type="image/png" sizes="32x32" href="favicon.svg" />
        <link rel="icon" type="image/png" sizes="16x16" href="favicon.svg" />
        <link rel="apple-touch-icon" sizes="180x180" href="favicon.svg" />
        <link rel="shortcut icon" href="favicon.svg" />
        <title>Goose Game</title>
        <meta property="og:title" content="Goose Game by AppleGeese!" />
        <meta
            property="og:description"
            content="Challenge yourself in the addictive Goose Game! Try to beat the high score and grow the longest neck. Play now!"
        />

        <meta property="og:url" content="https://applegeese.com/goose" />
        <meta property="og:type" content="game" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                -webkit-tap-highlight-color: transparent;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            body {
                font-family: "Arial", sans-serif;
                background: linear-gradient(135deg, #87ceeb 0%, #98fb98 100%);
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: #2f4f2f;
                margin: 0;
                padding: 0;
                overflow: hidden;
                transition:
                    background 0.3s ease,
                    color 0.3s ease;
                -webkit-overflow-scrolling: touch;
            }

            body.dark-mode {
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                color: #e4e4e7;
            }

            .game-container {
                background: rgba(255, 255, 255, 0.95);
                border-radius: 0;
                box-shadow: none;
                padding: 15px;
                text-align: center;
                width: 100vw;
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                transition: background 0.3s ease;
            }

            body.dark-mode .game-container {
                background: rgba(30, 30, 50, 0.95);
            }

            .game-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                font-size: 24px;
                font-weight: bold;
                color: #2f4f2f;
                padding: 0 20px;
                position: relative;
                transition: color 0.3s ease;
            }

            body.dark-mode .game-header {
                color: #e6e6e6;
            }

            .theme-toggle {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: transparent;
                border: 2px solid #2f4f2f;
                color: #2f4f2f;
                padding: 12px 16px;
                font-size: 16px;
                border-radius: 20px;
                cursor: pointer;
                transition: all 0.3s ease;
                z-index: 1000;
                min-height: 44px;
                min-width: 80px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .theme-toggle:hover {
                background: #2f4f2f;
                color: white;
                transform: scale(1.05);
            }

            body.dark-mode .theme-toggle {
                border-color: #e6e6e6;
                color: #e6e6e6;
            }

            body.dark-mode .theme-toggle:hover {
                background: #e6e6e6;
                color: #1a1a2e;
            }

            #gameCanvas {
                border: 4px solid #8b4513;
                border-radius: 8px;
                background: #90ee90;
                display: block;
                margin: 0 auto;
                max-width: 95vw;
                max-height: calc(100vh - 200px);
                transition: border-color 0.3s ease;
                touch-action: none;
            }

            body.dark-mode #gameCanvas {
                border-color: #4a4a6a;
            }

            .game-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 15px;
                font-size: 20px;
                color: #2f4f2f;
                padding: 0 20px;
                transition: color 0.3s ease;
            }

            body.dark-mode .game-footer {
                color: #e6e6e6;
            }

            .game-over-screen {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                padding: 40px;
                border-radius: 15px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                display: none;
                transition:
                    background 0.3s ease,
                    color 0.3s ease;
            }

            body.dark-mode .game-over-screen {
                background: rgba(30, 30, 50, 0.95);
                color: #e6e6e6;
            }

            .game-over-screen h2 {
                color: #b22222;
                margin-bottom: 20px;
                font-size: 28px;
            }

            .game-over-screen p {
                margin: 10px 0;
                font-size: 18px;
            }

            .start-screen {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                padding: 40px;
                border-radius: 15px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                transition:
                    background 0.3s ease,
                    color 0.3s ease;
            }

            body.dark-mode .start-screen {
                background: rgba(30, 30, 50, 0.95);
                color: #e6e6e6;
            }

            .start-screen h1 {
                color: #2f4f2f;
                margin-bottom: 20px;
                font-size: 32px;
                transition: color 0.3s ease;
            }

            body.dark-mode .start-screen h1 {
                color: #e6e6e6;
            }

            .start-screen .goose-emoji {
                font-size: 48px;
                margin: 20px 0;
            }

            .controls {
                margin: 20px 0;
                font-size: 14px;
                color: #555;
            }

            button {
                background: #32cd32;
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 8px;
                cursor: pointer;
                margin: 10px;
                transition: background 0.3s ease;
            }

            button:hover {
                background: #228b22;
            }

            button:active {
                transform: scale(0.95);
            }

            .pause-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                display: none;
            }

            .mobile-controls {
                display: none;
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 1000;
            }

            .control-pad {
                display: flex;
                justify-content: center;
                margin-bottom: 10px;
            }

            .control-btn {
                background: rgba(47, 79, 47, 0.8);
                border: 2px solid #2f4f2f;
                color: white;
                border-radius: 12px;
                font-size: 20px;
                cursor: pointer;
                transition: all 0.2s ease;
                touch-action: manipulation;
                user-select: none;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 60px;
                min-width: 60px;
            }

            .control-btn:active {
                background: rgba(47, 79, 47, 1);
                transform: scale(0.95);
            }

            .control-btn.pause {
                background: rgba(178, 34, 34, 0.8);
                border-color: #b22222;
            }

            .control-btn.pause:active {
                background: rgba(178, 34, 34, 1);
            }

            body.dark-mode .control-btn {
                background: rgba(230, 230, 230, 0.8);
                border-color: #e6e6e6;
                color: #1a1a2e;
            }

            body.dark-mode .control-btn:active {
                background: rgba(230, 230, 230, 1);
            }

            body.dark-mode .control-btn.pause {
                background: rgba(220, 20, 60, 0.8);
                border-color: #dc143c;
                color: white;
            }

            body.dark-mode .control-btn.pause:active {
                background: rgba(220, 20, 60, 1);
            }

            @media (max-width: 768px) {
                .mobile-controls {
                    display: block;
                }

                .theme-toggle {
                    bottom: 300px;
                    right: 10px;
                    padding: 16px 20px;
                    font-size: 18px;
                    min-height: 48px;
                    min-width: 100px;
                }

                .game-header {
                    font-size: 18px;
                    padding: 0 10px;
                    flex-wrap: wrap;
                    gap: 10px;
                }

                .game-footer {
                    font-size: 16px;
                    padding: 0 10px;
                    margin-bottom: 60px;
                }

                #gameCanvas {
                    max-height: calc(100vh - 280px);
                    border-width: 2px;
                }

                .start-screen,
                .game-over-screen {
                    padding: 20px;
                    margin: 10px;
                    max-width: calc(100vw - 20px);
                }

                .start-screen h1 {
                    font-size: 24px;
                }

                .start-screen .goose-emoji {
                    font-size: 32px;
                }

                button {
                    padding: 16px 24px;
                    font-size: 18px;
                    min-height: 48px;
                }

                .controls {
                    font-size: 12px;
                }
            }

            @media (max-width: 480px) {
                .game-header {
                    font-size: 16px;
                }

                .game-footer {
                    font-size: 14px;
                }

                .control-pad {
                    /* Keep flex layout for single button */
                }

                .control-btn {
                    min-height: 50px;
                    min-width: 50px;
                    font-size: 18px;
                }

                .theme-toggle {
                    bottom: 260px;
                    padding: 12px 16px;
                    font-size: 16px;
                    min-width: 90px;
                }

                #gameCanvas {
                    max-height: calc(100vh - 240px);
                }
            }

            .music-toggle {
                position: fixed;
                top: 20px;
                right: 20px;
                background: transparent;
                border: 2px solid #2f4f2f;
                color: #2f4f2f;
                padding: 12px 16px;
                font-size: 16px;
                border-radius: 20px;
                cursor: pointer;
                transition: all 0.3s ease;
                z-index: 1000;
                min-height: 44px;
                min-width: 80px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .music-toggle:hover {
                background: #2f4f2f;
                color: white;
                transform: scale(1.05);
            }

            body.dark-mode .music-toggle {
                border-color: #e6e6e6;
                color: #e6e6e6;
            }

            body.dark-mode .music-toggle:hover {
                background: #e6e6e6;
                color: #1a1a2e;
            }

            .settings-toggle {
                position: fixed;
                top: 20px;
                right: 20px;
                background: transparent;
                border: 2px solid #2f4f2f;
                color: #2f4f2f;
                padding: 12px;
                font-size: 20px;
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.3s ease;
                z-index: 1001;
                min-height: 48px;
                min-width: 48px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .settings-toggle:hover {
                background: #2f4f2f;
                color: white;
                transform: scale(1.1) rotate(90deg);
            }

            body.dark-mode .settings-toggle {
                border-color: #e6e6e6;
                color: #e6e6e6;
            }

            body.dark-mode .settings-toggle:hover {
                background: #e6e6e6;
                color: #1a1a2e;
            }

            .settings-menu {
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(255, 255, 255, 0.95);
                border: 2px solid #2f4f2f;
                border-radius: 12px;
                padding: 20px;
                min-width: 200px;
                z-index: 1000;
                display: none;
                backdrop-filter: blur(10px);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            }

            body.dark-mode .settings-menu {
                background: rgba(30, 30, 50, 0.95);
                border-color: #e6e6e6;
                color: #e6e6e6;
            }

            .settings-menu h3 {
                margin: 0 0 15px 0;
                font-size: 18px;
                text-align: center;
                border-bottom: 1px solid #ccc;
                padding-bottom: 10px;
            }

            body.dark-mode .settings-menu h3 {
                border-bottom-color: #666;
            }

            .setting-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .setting-item:last-child {
                margin-bottom: 0;
            }

            .setting-label {
                font-size: 16px;
                font-weight: 500;
            }

            .setting-button {
                background: #32cd32;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                min-width: 80px;
                transition: all 0.2s ease;
            }

            .setting-button:hover {
                background: #228b22;
                transform: scale(1.05);
            }

            .setting-button:active {
                transform: scale(0.95);
            }

            @media (max-width: 768px) {
                .settings-toggle {
                    top: 15px;
                    right: 15px;
                    min-height: 52px;
                    min-width: 52px;
                    font-size: 22px;
                }

                .settings-menu {
                    top: 75px;
                    right: 15px;
                    min-width: 180px;
                }
            }
        </style>
    </head>
    <body>
        <div class="game-container">
            <div class="game-header">
                <span>Score: <span id="score">0</span></span>
                <span>ü™ø Goose Game üçé</span>
                <span>High: <span id="highScore">0</span></span>
            </div>

            <canvas id="gameCanvas" width="600" height="400"></canvas>

            <div class="game-footer">
                <span>Neck Length: <span id="neckLength">1</span></span>
                <span>Speed: <span id="speed">1.0</span>x</span>
            </div>

            <div class="start-screen" id="startScreen">
                <h1>ü™ø Goose Game</h1>
                <div class="goose-emoji">ü™ø</div>
                <p>Help the goose eat apples and grow its neck!</p>
                <div class="controls">
                    <p><strong>Controls:</strong></p>
                    <p>Arrow Keys/WASD or Swipe to move</p>
                    <p>Spacebar or Pause button to pause</p>
                    <p>Enter to restart</p>
                    <p>Theme button: System ‚Üí Light ‚Üí Dark</p>
                </div>
                <button onclick="startGame()">Start Game</button>
            </div>

            <div class="game-over-screen" id="gameOverScreen">
                <h2>Game Over! ü™ø</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Neck Length: <span id="finalNeckLength">1</span></p>
                <p
                    id="newHighScore"
                    style="display: none; color: #32cd32; font-weight: bold"
                >
                    üéâ New High Score! üéâ
                </p>
                <button onclick="restartGame()">Play Again</button>
                <button onclick="showStartScreen()">Main Menu</button>
                <button
                    id="shareBlueskyButton"
                    style="
                        display: none;
                        background-color: #0096ff;
                        margin: 10px auto;
                        display: block;
                    "
                >
                    <i class="fa-brands fa-bluesky"></i> Share
                </button>
            </div>

            <div class="pause-overlay" id="pauseOverlay">
                <p>Game Paused</p>
                <p style="font-size: 16px; margin-top: 10px">
                    Press Spacebar or Pause button to resume
                </p>
            </div>
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-pad">
                <button class="control-btn pause" id="pauseBtn">‚è∏</button>
            </div>
        </div>

        <!-- Background music -->
        <audio id="backgroundMusic" loop preload="auto">
            <!-- Arcade soundtrack -->
            <source src="assets/goose/arcade.mp3" type="audio/mpeg" />
        </audio>

        <!-- Settings button -->
        <button
            class="settings-toggle"
            onclick="toggleSettings()"
            id="settingsToggle"
        >
            ‚öôÔ∏è
        </button>

        <!-- Settings menu -->
        <div class="settings-menu" id="settingsMenu">
            <h3>‚öôÔ∏è Settings</h3>
            <div class="setting-item">
                <span class="setting-label">Music</span>
                <button
                    class="setting-button"
                    onclick="toggleMusic()"
                    id="musicToggle"
                >
                    üéµ On
                </button>
            </div>
            <div class="setting-item">
                <span class="setting-label">Theme</span>
                <button
                    class="setting-button"
                    onclick="toggleTheme()"
                    id="themeToggle"
                >
                    üåô Dark
                </button>
            </div>
        </div>

        <script>
            // Game constants - Calculate dynamic canvas size
            const calculateCanvasSize = () => {
                const isMobile = window.innerWidth <= 768;
                const maxWidth = window.innerWidth * 0.95;
                const headerFooterHeight = isMobile ? 280 : 200;
                const maxHeight =
                    (window.innerHeight - headerFooterHeight) * 0.95;
                const GRID_SIZE = 30; // Larger grid squares

                const gridWidth = Math.floor(maxWidth / GRID_SIZE);
                const gridHeight = Math.floor(maxHeight / GRID_SIZE);

                return {
                    GRID_SIZE: GRID_SIZE,
                    GRID_WIDTH: gridWidth,
                    GRID_HEIGHT: gridHeight,
                    CANVAS_WIDTH: gridWidth * GRID_SIZE,
                    CANVAS_HEIGHT: gridHeight * GRID_SIZE,
                };
            };

            let gameSize = calculateCanvasSize();
            let GRID_SIZE = gameSize.GRID_SIZE;
            let GRID_WIDTH = gameSize.GRID_WIDTH;
            let GRID_HEIGHT = gameSize.GRID_HEIGHT;
            let CANVAS_WIDTH = gameSize.CANVAS_WIDTH;
            let CANVAS_HEIGHT = gameSize.CANVAS_HEIGHT;

            // Game elements
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            const scoreElement = document.getElementById("score");
            const highScoreElement = document.getElementById("highScore");
            const neckLengthElement = document.getElementById("neckLength");
            const speedElement = document.getElementById("speed");

            // Particle system
            let particles = [];
            let sparkleTimer = 0;
            let screenShake = { x: 0, y: 0, intensity: 0 };
            let trailParticles = [];

            // Game state
            let gameState = "start"; // 'start', 'playing', 'paused', 'gameOver'
            let gameLoop = null;
            let lastUpdateTime = 0;
            let updateInterval = 100; // milliseconds between updates

            // Game objects
            let goose = [];
            let apples = [];
            let powerups = [];
            let direction = { x: 1, y: 0 };
            let nextDirection = { x: 1, y: 0 };
            let score = 0;
            let highScore = parseInt(
                localStorage.getItem("gooseGameHighScore") || "0",
            );
            let speed = 1.0;
            let powerupTimer = 0;
            let appleSpawnTimer = 0;

            // Initialize high score display
            highScoreElement.textContent = highScore;

            // Particle class for effects
            class Particle {
                constructor(x, y, type = "apple") {
                    this.x = x;
                    this.y = y;
                    this.originalX = x;
                    this.originalY = y;
                    this.type = type;
                    this.life = 1.0;
                    this.maxLife =
                        type === "sparkle" ? 2.0 : type === "trail" ? 0.5 : 1.0;

                    if (type === "apple") {
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = (Math.random() - 0.5) * 8 - 3;
                        this.gravity = 0.2;
                        this.size = Math.random() * 4 + 2;
                        this.color = `hsl(${Math.random() * 60 + 30}, 100%, 60%)`; // Yellow to red
                    } else if (type === "gameOver") {
                        this.vx = (Math.random() - 0.5) * 6;
                        this.vy = Math.random() * -8 - 2;
                        this.gravity = 0.15;
                        this.size = Math.random() * 6 + 3;
                        this.color = `hsl(0, 100%, ${Math.random() * 50 + 50}%)`; // Red shades
                    } else if (type === "sparkle") {
                        this.angle = Math.random() * Math.PI * 2;
                        this.radius = Math.random() * 20 + 10;
                        this.angularVel = (Math.random() - 0.5) * 0.1;
                        this.size = Math.random() * 2 + 1;
                        this.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
                        this.twinkle = Math.random() * Math.PI * 2;
                    } else if (type === "trail") {
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                        this.size = Math.random() * 3 + 1;
                        this.color = `hsla(45, 80%, 85%, 0.6)`;
                    } else if (type === "explosion") {
                        this.vx = (Math.random() - 0.5) * 16;
                        this.vy = (Math.random() - 0.5) * 16 - 5;
                        this.gravity = 0.3;
                        this.size = Math.random() * 8 + 4;
                        this.color = `hsl(${Math.random() * 60 + 10}, 100%, ${Math.random() * 30 + 50}%)`; // Orange to red
                        this.spin = Math.random() * 0.2 - 0.1;
                        this.angle = 0;
                    }
                }

                update() {
                    this.life -= 1 / (this.maxLife * 60); // Assuming 60 FPS

                    if (
                        this.type === "apple" ||
                        this.type === "gameOver" ||
                        this.type === "trail" ||
                        this.type === "explosion"
                    ) {
                        this.x += this.vx;
                        this.y += this.vy;
                        if (this.gravity) this.vy += this.gravity;
                        if (this.spin) this.angle += this.spin;
                    } else if (this.type === "sparkle") {
                        this.angle += this.angularVel;
                        this.twinkle += 0.15;
                        this.x =
                            this.originalX +
                            Math.cos(this.angle) * this.radius * this.life;
                        this.y =
                            this.originalY +
                            Math.sin(this.angle) * this.radius * this.life;
                    }

                    return this.life > 0;
                }

                draw(ctx) {
                    const alpha = Math.max(0, this.life);

                    if (this.type === "sparkle") {
                        const twinkleAlpha = (Math.sin(this.twinkle) + 1) * 0.5;
                        ctx.globalAlpha = alpha * twinkleAlpha;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (this.type === "explosion") {
                        ctx.globalAlpha = alpha;
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        ctx.fillStyle = this.color;
                        ctx.fillRect(
                            -this.size / 2,
                            -this.size / 2,
                            this.size,
                            this.size,
                        );
                        ctx.restore();
                    } else {
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(
                            this.x,
                            this.y,
                            this.size * alpha,
                            0,
                            Math.PI * 2,
                        );
                        ctx.fill();
                    }

                    ctx.globalAlpha = 1;
                }
            }

            // Powerup system
            class Powerup {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.active = true;
                    this.life = 1.0;
                    this.pulse = 0;
                    this.sparkleTimer = 0;

                    switch (type) {
                        case "speed":
                            this.color = "#FFD700";
                            this.icon = "‚ö°";
                            this.duration = 300; // 5 seconds at 60fps
                            break;
                        case "shield":
                            this.color = "#00BFFF";
                            this.icon = "üõ°Ô∏è";
                            this.duration = 600; // 10 seconds
                            break;
                        case "rainbow":
                            this.color = "#FF1493";
                            this.icon = "üåà";
                            this.duration = 240; // 4 seconds
                            break;
                    }
                }

                update() {
                    this.pulse += 0.1;
                    this.sparkleTimer++;

                    // Create sparkle effect around powerup
                    if (this.sparkleTimer > 10 && Math.random() < 0.3) {
                        const sparkleX =
                            this.x * GRID_SIZE +
                            GRID_SIZE / 2 +
                            (Math.random() - 0.5) * GRID_SIZE;
                        const sparkleY =
                            this.y * GRID_SIZE +
                            GRID_SIZE / 2 +
                            (Math.random() - 0.5) * GRID_SIZE;
                        particles.push(
                            new Particle(sparkleX, sparkleY, "sparkle"),
                        );
                        this.sparkleTimer = 0;
                    }

                    return this.active;
                }

                draw(ctx) {
                    const x = this.x * GRID_SIZE;
                    const y = this.y * GRID_SIZE;
                    const centerX = x + GRID_SIZE / 2;
                    const centerY = y + GRID_SIZE / 2;

                    // Draw pulsing background
                    const pulseSize = 1 + Math.sin(this.pulse) * 0.2;
                    ctx.fillStyle = this.color + "40"; // Semi-transparent
                    ctx.beginPath();
                    ctx.arc(
                        centerX,
                        centerY,
                        (GRID_SIZE / 2 - 2) * pulseSize,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();

                    // Draw powerup icon
                    ctx.font = `${GRID_SIZE * 0.7}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = this.color;
                    ctx.fillText(this.icon, centerX, centerY);
                }
            }

            function createAppleEatEffect(x, y) {
                for (let i = 0; i < 12; i++) {
                    particles.push(
                        new Particle(
                            x + GRID_SIZE / 2,
                            y + GRID_SIZE / 2,
                            "apple",
                        ),
                    );
                }
            }

            function createGooseExplosion(gooseX, gooseY) {
                // Create explosion particles at goose head location
                for (let i = 0; i < 60; i++) {
                    particles.push(new Particle(gooseX, gooseY, "explosion"));
                }

                // Add some white flash particles for extra drama
                for (let i = 0; i < 15; i++) {
                    const flashParticle = new Particle(
                        gooseX,
                        gooseY,
                        "explosion",
                    );
                    flashParticle.color = "rgba(255, 255, 255, 0.9)";
                    flashParticle.size *= 1.5;
                    particles.push(flashParticle);
                }

                // Create screen shake for dramatic effect
                createScreenShake(12);
            }

            function createSparkleEffect() {
                if (goose.length > 0 && gameState === "playing") {
                    const head = goose[0];
                    const x = head.x * GRID_SIZE + GRID_SIZE / 2;
                    const y = head.y * GRID_SIZE + GRID_SIZE / 2;

                    particles.push(new Particle(x, y, "sparkle"));
                }
            }

            function createTrailEffect() {
                if (goose.length > 1 && gameState === "playing") {
                    // Add trail particles to the last few segments
                    for (
                        let i = Math.max(0, goose.length - 3);
                        i < goose.length;
                        i++
                    ) {
                        const segment = goose[i];
                        const x = segment.x * GRID_SIZE + GRID_SIZE / 2;
                        const y = segment.y * GRID_SIZE + GRID_SIZE / 2;

                        if (Math.random() < 0.3) {
                            particles.push(
                                new Particle(
                                    x + (Math.random() - 0.5) * GRID_SIZE,
                                    y + (Math.random() - 0.5) * GRID_SIZE,
                                    "trail",
                                ),
                            );
                        }
                    }
                }
            }

            function createScreenShake(intensity) {
                screenShake.intensity = intensity;
            }

            function updateScreenShake() {
                if (screenShake.intensity > 0) {
                    screenShake.x =
                        (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.y =
                        (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.intensity *= 0.8; // Decay shake

                    if (screenShake.intensity < 0.1) {
                        screenShake.intensity = 0;
                        screenShake.x = 0;
                        screenShake.y = 0;
                    }
                }
            }

            function updateParticles() {
                particles = particles.filter((particle) => particle.update());
                updateScreenShake();

                // Add ambient sparkles occasionally
                sparkleTimer++;
                if (
                    sparkleTimer > 120 &&
                    gameState === "playing" &&
                    Math.random() < 0.3
                ) {
                    // Every 2 seconds roughly
                    createSparkleEffect();
                    sparkleTimer = 0;
                }

                // Add trail particles occasionally
                if (gameState === "playing" && Math.random() < 0.4) {
                    createTrailEffect();
                }
            }

            function updatePowerups() {
                powerups = powerups.filter((powerup) => powerup.update());

                // Spawn powerups occasionally
                powerupTimer++;
                if (powerupTimer > 1800 && Math.random() < 0.03) {
                    // Every 30 seconds roughly
                    spawnPowerup();
                    powerupTimer = 0;
                }
            }

            function drawParticles(ctx) {
                particles.forEach((particle) => particle.draw(ctx));
            }

            function drawFieldBackground(ctx, isDarkMode) {
                // Simple field background with gradient
                const gradient = ctx.createLinearGradient(
                    0,
                    0,
                    0,
                    CANVAS_HEIGHT,
                );
                gradient.addColorStop(0, isDarkMode ? "#2d4a2d" : "#81C784");
                gradient.addColorStop(1, isDarkMode ? "#1a3d1a" : "#4CAF50");

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Simple grid overlay
                ctx.strokeStyle = isDarkMode
                    ? "rgba(255, 255, 255, 0.08)"
                    : "rgba(0, 0, 0, 0.08)";
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_WIDTH; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * GRID_SIZE, 0);
                    ctx.lineTo(x * GRID_SIZE, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_HEIGHT; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * GRID_SIZE);
                    ctx.lineTo(CANVAS_WIDTH, y * GRID_SIZE);
                    ctx.stroke();
                }
            }

            // Set initial canvas size
            function setCanvasSize() {
                gameSize = calculateCanvasSize();
                GRID_SIZE = gameSize.GRID_SIZE;
                GRID_WIDTH = gameSize.GRID_WIDTH;
                GRID_HEIGHT = gameSize.GRID_HEIGHT;
                CANVAS_WIDTH = gameSize.CANVAS_WIDTH;
                CANVAS_HEIGHT = gameSize.CANVAS_HEIGHT;

                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
            }

            // Handle window resize
            window.addEventListener("resize", () => {
                if (gameState === "start") {
                    setCanvasSize();
                    render();
                }
                updateMobileControlsVisibility();
            });

            // Set initial size
            setCanvasSize();

            // Initialize mobile controls visibility
            updateMobileControlsVisibility();

            // Handle orientation change
            window.addEventListener("orientationchange", () => {
                setTimeout(() => {
                    setCanvasSize();
                    updateMobileControlsVisibility();
                    if (gameState === "start") {
                        render();
                    }
                }, 100);
            });

            // Game initialization
            function initializeGame() {
                setCanvasSize(); // Ensure canvas is properly sized
                goose = [
                    {
                        x: Math.floor(GRID_WIDTH / 4),
                        y: Math.floor(GRID_HEIGHT / 2),
                    },
                ]; // Start goose head at position
                direction = { x: 1, y: 0 };
                nextDirection = { x: 1, y: 0 };
                score = 0;
                speed = 1.0;
                updateInterval = 100;

                // Clear arrays and reset timers
                apples = [];
                powerups = [];
                activePowerups = {};
                powerupTimer = 0;
                appleSpawnTimer = 0;

                spawnApple();
                updateUI();
            }

            // Spawn apple at random location
            function spawnApple() {
                if (apples.length >= 3) return; // Max 3 apples

                let validPosition = false;
                let attempts = 0;
                let newApple;

                while (!validPosition && attempts < 50) {
                    newApple = {
                        x: Math.floor(Math.random() * GRID_WIDTH),
                        y: Math.floor(Math.random() * GRID_HEIGHT),
                        isGolden: Math.random() < 0.15,
                    };

                    validPosition =
                        !goose.some(
                            (segment) =>
                                segment.x === newApple.x &&
                                segment.y === newApple.y,
                        ) &&
                        !powerups.some(
                            (powerup) =>
                                powerup.x === newApple.x &&
                                powerup.y === newApple.y,
                        ) &&
                        !apples.some(
                            (apple) =>
                                apple.x === newApple.x &&
                                apple.y === newApple.y,
                        );

                    attempts++;
                }

                if (validPosition) {
                    apples.push(newApple);
                }
            }

            function spawnPowerup() {
                if (powerups.length >= 2) return; // Max 2 powerups at once

                const types = ["speed", "shield", "rainbow"];
                const type = types[Math.floor(Math.random() * types.length)];

                let validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 50) {
                    const x = Math.floor(Math.random() * GRID_WIDTH);
                    const y = Math.floor(Math.random() * GRID_HEIGHT);

                    validPosition =
                        !goose.some(
                            (segment) => segment.x === x && segment.y === y,
                        ) &&
                        !powerups.some(
                            (powerup) => powerup.x === x && powerup.y === y,
                        ) &&
                        !apples.some((apple) => apple.x === x && apple.y === y);

                    if (validPosition) {
                        powerups.push(new Powerup(x, y, type));
                    }
                    attempts++;
                }
            }

            // Update game UI
            function updateUI() {
                scoreElement.textContent = score;
                neckLengthElement.textContent = goose.length;
                speedElement.textContent = speed.toFixed(1);
            }

            // Input handling
            document.addEventListener("keydown", (event) => {
                if (gameState === "playing") {
                    switch (event.key) {
                        case "ArrowUp":
                        case "w":
                        case "W":
                            if (direction.y !== 1) {
                                nextDirection = { x: 0, y: -1 };
                            }
                            event.preventDefault();
                            break;
                        case "ArrowDown":
                        case "s":
                        case "S":
                            if (direction.y !== -1) {
                                nextDirection = { x: 0, y: 1 };
                            }
                            event.preventDefault();
                            break;
                        case "ArrowLeft":
                        case "a":
                        case "A":
                            if (direction.x !== 1) {
                                nextDirection = { x: -1, y: 0 };
                            }
                            event.preventDefault();
                            break;
                        case "ArrowRight":
                        case "d":
                        case "D":
                            if (direction.x !== -1) {
                                nextDirection = { x: 1, y: 0 };
                            }
                            event.preventDefault();
                            break;
                        case " ":
                            pauseGame();
                            event.preventDefault();
                            break;
                    }
                } else if (gameState === "paused") {
                    if (event.key === " ") {
                        resumeGame();
                        event.preventDefault();
                    }
                } else if (gameState === "gameOver" || gameState === "start") {
                    if (event.key === "Enter") {
                        if (gameState === "gameOver") {
                            restartGame();
                        } else {
                            startGame();
                        }
                        event.preventDefault();
                    }
                }
            });

            // Mobile touch controls and swipe gestures
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            // Function to handle direction changes
            function changeDirection(newDirection) {
                if (gameState === "playing") {
                    switch (newDirection) {
                        case "up":
                            if (direction.y !== 1) {
                                nextDirection = { x: 0, y: -1 };
                            }
                            break;
                        case "down":
                            if (direction.y !== -1) {
                                nextDirection = { x: 0, y: 1 };
                            }
                            break;
                        case "left":
                            if (direction.x !== 1) {
                                nextDirection = { x: -1, y: 0 };
                            }
                            break;
                        case "right":
                            if (direction.x !== -1) {
                                nextDirection = { x: 1, y: 0 };
                            }
                            break;
                    }
                }
            }

            // Mobile pause button
            document
                .getElementById("pauseBtn")
                .addEventListener("touchstart", (e) => {
                    e.preventDefault();
                    if (gameState === "playing") {
                        pauseGame();
                    } else if (gameState === "paused") {
                        resumeGame();
                    }
                });

            // Also add click event for desktop testing
            document
                .getElementById("pauseBtn")
                .addEventListener("click", () => {
                    if (gameState === "playing") {
                        pauseGame();
                    } else if (gameState === "paused") {
                        resumeGame();
                    }
                });

            // Swipe detection on canvas
            canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            canvas.addEventListener("touchend", (e) => {
                e.preventDefault();
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const minSwipeDistance = 30;

                if (
                    Math.abs(deltaX) < minSwipeDistance &&
                    Math.abs(deltaY) < minSwipeDistance
                ) {
                    return; // Too small to be a swipe
                }

                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal swipe
                    if (deltaX > 0) {
                        changeDirection("right");
                    } else {
                        changeDirection("left");
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0) {
                        changeDirection("down");
                    } else {
                        changeDirection("up");
                    }
                }
            }

            // Update pause button text based on game state
            function updatePauseButton() {
                const pauseBtn = document.getElementById("pauseBtn");
                if (gameState === "paused") {
                    pauseBtn.textContent = "‚ñ∂";
                } else {
                    pauseBtn.textContent = "‚è∏";
                }
            }

            // Mobile controls visibility management
            function updateMobileControlsVisibility() {
                const isMobile = window.innerWidth <= 768;
                const mobileControls =
                    document.getElementById("mobileControls");
                if (isMobile) {
                    mobileControls.style.display = "block";
                } else {
                    mobileControls.style.display = "none";
                }
            }

            // Game loop
            function gameUpdate(currentTime) {
                if (gameState !== "playing" && gameState !== "gameOver") return;

                // Update particles regardless of game update interval
                updateParticles();

                // Update powerups
                if (gameState === "playing") {
                    updatePowerups();
                    updateActivePowerups();

                    // Spawn additional apples over time
                    appleSpawnTimer++;
                    if (apples.length === 0) {
                        // Always ensure at least one apple
                        spawnApple();
                        appleSpawnTimer = 0;
                    } else if (appleSpawnTimer > 90 && apples.length < 3) {
                        // Every 1.5 seconds if we have apples
                        spawnApple();
                        appleSpawnTimer = 0;
                    }
                }

                if (currentTime - lastUpdateTime >= updateInterval) {
                    direction = { ...nextDirection };

                    // Move goose
                    const head = { ...goose[0] };
                    head.x += direction.x;
                    head.y += direction.y;

                    // Check wall collisions
                    if (
                        head.x < 0 ||
                        head.x >= GRID_WIDTH ||
                        head.y < 0 ||
                        head.y >= GRID_HEIGHT
                    ) {
                        // Shield powerup prevents death
                        if (
                            activePowerups.shield &&
                            activePowerups.shield.active
                        ) {
                            // Consume shield and wrap around
                            delete activePowerups.shield;
                            head.x = (head.x + GRID_WIDTH) % GRID_WIDTH;
                            head.y = (head.y + GRID_HEIGHT) % GRID_HEIGHT;
                            createScreenShake(3);
                        } else {
                            // Store the last valid goose head position BEFORE clearing
                            const lastValidX =
                                goose[0].x * GRID_SIZE + GRID_SIZE / 2;
                            const lastValidY =
                                goose[0].y * GRID_SIZE + GRID_SIZE / 2;

                            // Capture game state before clearing
                            const finalScore = score;
                            const finalNeckLength = goose.length;

                            // Clear goose immediately so it doesn't show during explosion
                            goose = [];

                            // Create explosion at last valid position
                            createGooseExplosion(lastValidX, lastValidY);
                            gameOver(finalScore, finalNeckLength);
                            return;
                        }
                    }

                    // Check self collision
                    if (
                        goose.some(
                            (segment) =>
                                segment.x === head.x && segment.y === head.y,
                        )
                    ) {
                        // Shield powerup prevents death
                        if (
                            activePowerups.shield &&
                            activePowerups.shield.active
                        ) {
                            // Consume shield and bounce off
                            delete activePowerups.shield;
                            // Reverse direction
                            nextDirection = {
                                x: -direction.x,
                                y: -direction.y,
                            };
                            createScreenShake(3);
                        } else {
                            // Store collision position BEFORE clearing goose
                            const collisionX =
                                head.x * GRID_SIZE + GRID_SIZE / 2;
                            const collisionY =
                                head.y * GRID_SIZE + GRID_SIZE / 2;

                            // Capture game state before clearing
                            const finalScore = score;
                            const finalNeckLength = goose.length;

                            // Clear goose immediately so it doesn't show during explosion
                            goose = [];

                            // Create explosion at collision position
                            createGooseExplosion(collisionX, collisionY);
                            gameOver(finalScore, finalNeckLength);
                            return;
                        }
                    }

                    goose.unshift(head);

                    // Check apple collisions
                    let appleEaten = false;
                    for (let i = apples.length - 1; i >= 0; i--) {
                        const apple = apples[i];
                        if (head.x === apple.x && head.y === apple.y) {
                            // Create apple eating particle effect
                            createAppleEatEffect(
                                apple.x * GRID_SIZE,
                                apple.y * GRID_SIZE,
                            );

                            // Create screen shake effect
                            createScreenShake(3);

                            // Apple eaten - don't remove tail, goose grows
                            let applePoints = apple.isGolden ? 25 : 10;

                            // Rainbow powerup doubles points
                            if (
                                activePowerups.rainbow &&
                                activePowerups.rainbow.active
                            ) {
                                applePoints *= 2;
                            }

                            score += applePoints;

                            // Length bonus
                            score += goose.length * 5;

                            // Increase speed every 100 points
                            let baseSpeed = 1.0 + Math.floor(score / 100) * 0.5;

                            // Speed powerup effect
                            if (
                                activePowerups.speed &&
                                activePowerups.speed.active
                            ) {
                                baseSpeed *= 1.5;
                            }

                            if (baseSpeed <= 5.0) {
                                speed = baseSpeed;
                                updateInterval = Math.max(
                                    50,
                                    100 / Math.pow(speed, 0.5),
                                );
                            }

                            // Remove eaten apple and spawn new one
                            apples.splice(i, 1);
                            appleEaten = true;
                            playEatSound();
                            break;
                        }
                    }

                    if (!appleEaten) {
                        // Remove tail if no apple eaten
                        goose.pop();
                    }

                    // Check powerup collisions
                    for (let i = powerups.length - 1; i >= 0; i--) {
                        const powerup = powerups[i];
                        if (head.x === powerup.x && head.y === powerup.y) {
                            // Consume powerup
                            activatePowerup(powerup.type);
                            powerups.splice(i, 1);

                            // Create collection effect
                            createPowerupEffect(
                                powerup.x * GRID_SIZE + GRID_SIZE / 2,
                                powerup.y * GRID_SIZE + GRID_SIZE / 2,
                                powerup.type,
                            );
                            score += 50; // Bonus points for powerup
                            break;
                        }
                    }

                    updateUI();
                    lastUpdateTime = currentTime;
                }

                render();
            }

            // Rendering
            function render() {
                // Save context and apply screen shake
                ctx.save();
                ctx.translate(screenShake.x, screenShake.y);

                // Clear canvas and draw field background
                const isDarkMode =
                    document.body.classList.contains("dark-mode");

                // Draw field background
                drawFieldBackground(ctx, isDarkMode);

                // Draw goose
                goose.forEach((segment, index) => {
                    const x = segment.x * GRID_SIZE;
                    const y = segment.y * GRID_SIZE;

                    if (index === 0) {
                        // Draw goose head
                        ctx.fillStyle = "#FFFAF0";
                        ctx.fillRect(
                            x + 2,
                            y + 2,
                            GRID_SIZE - 4,
                            GRID_SIZE - 4,
                        );
                        ctx.strokeStyle = "#DDD";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            x + 2,
                            y + 2,
                            GRID_SIZE - 4,
                            GRID_SIZE - 4,
                        );

                        // Draw beak
                        ctx.fillStyle = "#FF8C00";
                        const beakX = x + GRID_SIZE / 2;
                        const beakY = y + GRID_SIZE / 2;
                        ctx.beginPath();
                        if (direction.x === 1) {
                            // Right
                            ctx.moveTo(beakX + 3, beakY);
                            ctx.lineTo(beakX + 8, beakY - 3);
                            ctx.lineTo(beakX + 8, beakY + 3);
                        } else if (direction.x === -1) {
                            // Left
                            ctx.moveTo(beakX - 3, beakY);
                            ctx.lineTo(beakX - 8, beakY - 3);
                            ctx.lineTo(beakX - 8, beakY + 3);
                        } else if (direction.y === -1) {
                            // Up
                            ctx.moveTo(beakX, beakY - 3);
                            ctx.lineTo(beakX - 3, beakY - 8);
                            ctx.lineTo(beakX + 3, beakY - 8);
                        } else {
                            // Down
                            ctx.moveTo(beakX, beakY + 3);
                            ctx.lineTo(beakX - 3, beakY + 8);
                            ctx.lineTo(beakX + 3, beakY + 8);
                        }
                        ctx.closePath();
                        ctx.fill();

                        // Draw eyes
                        ctx.fillStyle = "#000";
                        ctx.fillRect(x + 6, y + 5, 2, 2);
                        ctx.fillRect(x + 12, y + 5, 2, 2);
                    } else if (index === goose.length - 1) {
                        // Draw tail segment with feet
                        ctx.fillStyle = "#F5F5DC";
                        ctx.fillRect(
                            x + 3,
                            y + 3,
                            GRID_SIZE - 6,
                            GRID_SIZE - 6,
                        );
                        ctx.strokeStyle = "#DDD";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            x + 3,
                            y + 3,
                            GRID_SIZE - 6,
                            GRID_SIZE - 6,
                        );

                        // Draw little feet
                        ctx.fillStyle = "#FF8C00";
                        const footX = x + GRID_SIZE / 2;
                        const footY = y + GRID_SIZE - 2;

                        // Left foot
                        ctx.beginPath();
                        ctx.ellipse(
                            footX - 4,
                            footY + 2,
                            3,
                            2,
                            0,
                            0,
                            2 * Math.PI,
                        );
                        ctx.fill();

                        // Right foot
                        ctx.beginPath();
                        ctx.ellipse(
                            footX + 4,
                            footY + 2,
                            3,
                            2,
                            0,
                            0,
                            2 * Math.PI,
                        );
                        ctx.fill();

                        // Tiny toes (left foot)
                        ctx.fillStyle = "#E6740A";
                        ctx.fillRect(footX - 7, footY + 3, 1, 1);
                        ctx.fillRect(footX - 5, footY + 4, 1, 1);
                        ctx.fillRect(footX - 3, footY + 3, 1, 1);

                        // Tiny toes (right foot)
                        ctx.fillRect(footX + 1, footY + 3, 1, 1);
                        ctx.fillRect(footX + 3, footY + 4, 1, 1);
                        ctx.fillRect(footX + 5, footY + 3, 1, 1);
                    } else {
                        // Draw neck segment
                        ctx.fillStyle = "#F5F5DC";
                        ctx.fillRect(
                            x + 3,
                            y + 3,
                            GRID_SIZE - 6,
                            GRID_SIZE - 6,
                        );
                        ctx.strokeStyle = "#DDD";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            x + 3,
                            y + 3,
                            GRID_SIZE - 6,
                            GRID_SIZE - 6,
                        );
                    }
                });

                // Draw particles
                drawParticles(ctx);

                // Draw powerups
                powerups.forEach((powerup) => powerup.draw(ctx));

                // Restore context after screen shake
                ctx.restore();

                // Draw powerup status indicators
                drawPowerupIndicators(ctx);

                // Draw all apples
                apples.forEach((apple) => {
                    const appleX = apple.x * GRID_SIZE;
                    const appleY = apple.y * GRID_SIZE;

                    ctx.fillStyle = apple.isGolden ? "#FFD700" : "#DC143C";
                    ctx.beginPath();
                    ctx.arc(
                        appleX + GRID_SIZE / 2,
                        appleY + GRID_SIZE / 2,
                        GRID_SIZE / 2 - 2,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();

                    // Draw apple highlight
                    ctx.fillStyle = apple.isGolden ? "#FFF8DC" : "#FF6B6B";
                    ctx.beginPath();
                    ctx.arc(
                        appleX + GRID_SIZE / 2 - 3,
                        appleY + GRID_SIZE / 2 - 3,
                        3,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();

                    // Draw apple stem
                    ctx.strokeStyle = "#228B22";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(appleX + GRID_SIZE / 2, appleY + 3);
                    ctx.lineTo(appleX + GRID_SIZE / 2, appleY + 1);
                    ctx.stroke();
                });
            }

            // Game state functions
            function startGame() {
                gameState = "playing";
                document.getElementById("startScreen").style.display = "none";
                initializeGame();
                updatePauseButton();

                // Start background music if enabled
                if (musicEnabled) {
                    backgroundMusic.currentTime = 0;
                    backgroundMusic
                        .play()
                        .catch((e) => console.log("Audio play failed:", e));
                }

                lastUpdateTime = performance.now();
                gameLoop = requestAnimationFrame(function loop(time) {
                    gameUpdate(time);
                    render();
                    if (
                        gameState === "playing" ||
                        gameState === "paused" ||
                        gameState === "gameOver"
                    ) {
                        gameLoop = requestAnimationFrame(loop);
                    }
                });
            }

            function pauseGame() {
                if (gameState === "playing") {
                    gameState = "paused";
                    document.getElementById("pauseOverlay").style.display =
                        "block";
                    updatePauseButton();

                    // Pause background music
                    backgroundMusic.pause();
                }
            }

            function resumeGame() {
                if (gameState === "paused") {
                    gameState = "playing";
                    document.getElementById("pauseOverlay").style.display =
                        "none";
                    lastUpdateTime = performance.now();
                    updatePauseButton();

                    // Resume background music if enabled
                    if (musicEnabled) {
                        backgroundMusic
                            .play()
                            .catch((e) => console.log("Audio play failed:", e));
                    }
                }
            }

            function gameOver(finalScore, finalNeckLength) {
                gameState = "gameOver";

                // Update high score
                if (finalScore > highScore) {
                    highScore = finalScore;
                    localStorage.setItem(
                        "gooseGameHighScore",
                        highScore.toString(),
                    );
                    highScoreElement.textContent = highScore;
                    document.getElementById("newHighScore").style.display =
                        "block";
                } else {
                    document.getElementById("newHighScore").style.display =
                        "none";
                }

                document.getElementById("finalScore").textContent = finalScore;
                document.getElementById("finalNeckLength").textContent =
                    finalNeckLength;

                playGameOverSound();

                // Stop background music on game over
                backgroundMusic.pause();

                // Simple delay to let explosion play out completely
                setTimeout(() => {
                    document.getElementById("gameOverScreen").style.display =
                        "block";

                    const shareButton =
                        document.getElementById("shareBlueskyButton");
                    if (shareButton) {
                        const scoreToShare = finalScore;
                        let shareText = `I just scored ${scoreToShare} in Goose Game! Can you beat it? #GooseGame #applegeese\n\nhttps://applegeese.com/goose`;

                        if (finalScore === highScore) {
                            shareText = `I set a NEW HIGH SCORE of ${scoreToShare} in Goose Game! Try to beat it! #GooseGame #applegeese\n\nhttps://applegeese.com/goose`;
                        }

                        const blueskyShareUrl = `https://bsky.app/intent/compose?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(window.location.href)}`;

                        shareButton.style.display = "block"; // Make the button visible
                        shareButton.onclick = () => {
                            window.open(blueskyShareUrl, "_blank");
                        };
                    }
                }, 1500);
            }

            function restartGame() {
                document.getElementById("gameOverScreen").style.display =
                    "none";
                // Clear particles, powerups, and apples when restarting
                particles = [];
                powerups = [];
                activePowerups = {};
                apples = [];
                startGame();
            }

            function showStartScreen() {
                gameState = "start";
                document.getElementById("gameOverScreen").style.display =
                    "none";
                document.getElementById("startScreen").style.display = "block";

                // Reset the board
                initializeGame();
                render();
            }

            // Audio functions (simplified)
            function playEatSound() {
                // Simple audio feedback using Web Audio API
                try {
                    const audioContext = new (window.AudioContext ||
                        window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = apple.isGolden ? 800 : 600;
                    oscillator.type = "sine";

                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(
                        0.01,
                        audioContext.currentTime + 0.1,
                    );

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    // Audio not supported or blocked
                }
            }

            function playGameOverSound() {
                try {
                    const audioContext = new (window.AudioContext ||
                        window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 200;
                    oscillator.type = "sawtooth";

                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(
                        0.01,
                        audioContext.currentTime + 0.5,
                    );

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    // Audio not supported or blocked
                }
            }

            // Theme toggle functionality
            function toggleTheme() {
                const body = document.body;
                const themeButton = document.getElementById("themeToggle");
                const savedTheme = localStorage.getItem("gooseGameTheme");

                // Check system preference
                const supportsColorScheme =
                    window.matchMedia &&
                    window.matchMedia("(prefers-color-scheme)").media !==
                        "not all";
                const prefersDark =
                    supportsColorScheme &&
                    window.matchMedia("(prefers-color-scheme: dark)").matches;

                // Cycle through: system -> light -> dark -> system...
                if (!savedTheme) {
                    // Currently using system, switch to opposite of system (or light if no system support)
                    if (supportsColorScheme && prefersDark) {
                        body.classList.remove("dark-mode");
                        localStorage.setItem("gooseGameTheme", "light");
                    } else {
                        body.classList.add("dark-mode");
                        localStorage.setItem("gooseGameTheme", "dark");
                    }
                } else if (savedTheme === "light") {
                    // Switch to dark
                    body.classList.add("dark-mode");
                    localStorage.setItem("gooseGameTheme", "dark");
                } else if (savedTheme === "dark") {
                    // Switch to system
                    localStorage.removeItem("gooseGameTheme");
                    if (supportsColorScheme && prefersDark) {
                        body.classList.add("dark-mode");
                    } else {
                        body.classList.remove("dark-mode");
                    }
                }

                // Update button text after theme change
                updateThemeButtonText();

                // Re-render the game with new theme
                if (gameState !== "playing") {
                    render();
                }
            }

            function updateThemeButtonText() {
                const themeButton = document.getElementById("themeToggle");
                if (!themeButton) return; // Safety check
                const savedTheme = localStorage.getItem("gooseGameTheme");
                const supportsColorScheme =
                    window.matchMedia &&
                    window.matchMedia("(prefers-color-scheme)").media !==
                        "not all";
                const prefersDark =
                    supportsColorScheme &&
                    window.matchMedia("(prefers-color-scheme: dark)").matches;

                if (!savedTheme) {
                    if (supportsColorScheme) {
                        themeButton.textContent = prefersDark
                            ? "‚òÄÔ∏è Light"
                            : "üåô Dark";
                    } else {
                        themeButton.textContent = "üåô Dark";
                    }
                } else if (savedTheme === "dark") {
                    themeButton.textContent = supportsColorScheme
                        ? "üåø System"
                        : "‚òÄÔ∏è Light";
                } else {
                    themeButton.textContent = "üåô Dark";
                }
            }

            // Load saved theme on page load
            function loadTheme() {
                const savedTheme = localStorage.getItem("gooseGameTheme");

                // Check if system supports prefers-color-scheme
                const supportsColorScheme =
                    window.matchMedia &&
                    window.matchMedia("(prefers-color-scheme)").media !==
                        "not all";

                // Check system preference if supported and no saved theme
                let prefersDark = false;
                if (supportsColorScheme) {
                    prefersDark = window.matchMedia(
                        "(prefers-color-scheme: dark)",
                    ).matches;
                }

                let shouldUseDark = false;

                if (savedTheme) {
                    shouldUseDark = savedTheme === "dark";
                } else if (supportsColorScheme) {
                    shouldUseDark = prefersDark;
                } else {
                    // Fallback to light mode if system doesn't support color scheme detection
                    shouldUseDark = false;
                }

                if (shouldUseDark) {
                    document.body.classList.add("dark-mode");
                } else {
                    document.body.classList.remove("dark-mode");
                }

                updateThemeButtonText();
            }

            // Listen for system theme changes
            if (
                window.matchMedia &&
                window.matchMedia("(prefers-color-scheme)").media !== "not all"
            ) {
                window
                    .matchMedia("(prefers-color-scheme: dark)")
                    .addEventListener("change", (e) => {
                        // Only update if user hasn't manually set a preference
                        const savedTheme =
                            localStorage.getItem("gooseGameTheme");
                        if (!savedTheme) {
                            const themeButton =
                                document.querySelector(".theme-toggle");
                            const body = document.body;

                            if (e.matches) {
                                body.classList.add("dark-mode");
                            } else {
                                body.classList.remove("dark-mode");
                            }
                            updateThemeButtonText();

                            // Re-render the game with new theme
                            if (gameState !== "playing") {
                                render();
                            }
                        }
                    });
            }

            // Background music functions
            const backgroundMusic = document.getElementById("backgroundMusic");
            let musicEnabled =
                localStorage.getItem("gooseGameMusic") !== "false";

            function toggleSettings() {
                const settingsMenu = document.getElementById("settingsMenu");
                if (
                    settingsMenu.style.display === "none" ||
                    settingsMenu.style.display === ""
                ) {
                    settingsMenu.style.display = "block";
                } else {
                    settingsMenu.style.display = "none";
                }
            }

            // Close settings menu when clicking outside
            document.addEventListener("click", function (e) {
                const settingsMenu = document.getElementById("settingsMenu");
                const settingsToggle =
                    document.getElementById("settingsToggle");

                if (
                    !settingsMenu.contains(e.target) &&
                    !settingsToggle.contains(e.target)
                ) {
                    settingsMenu.style.display = "none";
                }
            });

            function toggleMusic() {
                const musicToggle = document.getElementById("musicToggle");

                if (musicEnabled) {
                    backgroundMusic.pause();
                    musicToggle.textContent = "üîá Off";
                    musicEnabled = false;
                    localStorage.setItem("gooseGameMusic", "false");
                } else {
                    if (gameState === "playing") {
                        backgroundMusic.currentTime = 0;
                        backgroundMusic
                            .play()
                            .catch((e) => console.log("Audio play failed:", e));
                    }
                    musicToggle.textContent = "üéµ On";
                    musicEnabled = true;
                    localStorage.setItem("gooseGameMusic", "true");
                }
            }

            function initMusic() {
                const musicToggle = document.getElementById("musicToggle");
                backgroundMusic.volume = 0.2; // Set volume to 20%
                backgroundMusic.loop = true; // Ensure audio loops

                // Handle audio loading errors
                backgroundMusic.addEventListener("error", () => {
                    console.log("Background music failed to load");
                    musicToggle.textContent = "‚ùå No Music";
                    musicToggle.disabled = true;
                    musicEnabled = false;
                });

                backgroundMusic.addEventListener("canplaythrough", () => {
                    console.log("Background music ready");
                });

                if (musicEnabled) {
                    musicToggle.textContent = "üéµ On";
                } else {
                    musicToggle.textContent = "üîá Off";
                }
            }

            // Powerup system variables
            let activePowerups = {};

            function activatePowerup(type) {
                activePowerups[type] = {
                    timeLeft: getPowerupDuration(type),
                    active: true,
                };

                // Apply immediate effects
                switch (type) {
                    case "speed":
                        // Speed boost is handled in game update
                        break;
                    case "shield":
                        // Shield prevents death for duration
                        break;
                    case "rainbow":
                        // Rainbow mode gives double points
                        break;
                }
            }

            function getPowerupDuration(type) {
                switch (type) {
                    case "speed":
                        return 300; // 5 seconds
                    case "shield":
                        return 600; // 10 seconds
                    case "rainbow":
                        return 240; // 4 seconds
                    default:
                        return 300;
                }
            }

            function createPowerupEffect(x, y, type) {
                const colors = {
                    speed: "#FFD700",
                    shield: "#00BFFF",
                    rainbow: "#FF1493",
                };

                for (let i = 0; i < 20; i++) {
                    const particle = new Particle(x, y, "apple");
                    particle.color = colors[type];
                    particle.size = Math.random() * 6 + 3;
                    particles.push(particle);
                }

                createScreenShake(5);
            }

            function updateActivePowerups() {
                for (const type in activePowerups) {
                    if (activePowerups[type].active) {
                        activePowerups[type].timeLeft--;
                        if (activePowerups[type].timeLeft <= 0) {
                            activePowerups[type].active = false;
                            delete activePowerups[type];
                        }
                    }
                }
            }

            function drawPowerupIndicators(ctx) {
                let yOffset = 10;
                const iconSize = 24;

                for (const type in activePowerups) {
                    if (activePowerups[type].active) {
                        const timeLeft = activePowerups[type].timeLeft;
                        const progress = timeLeft / getPowerupDuration(type);

                        // Draw background
                        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                        ctx.fillRect(10, yOffset, 120, iconSize + 4);

                        // Draw icon
                        ctx.font = `${iconSize}px Arial`;
                        ctx.textAlign = "left";
                        ctx.textBaseline = "top";

                        const icons = {
                            speed: "‚ö°",
                            shield: "üõ°Ô∏è",
                            rainbow: "üåà",
                        };

                        ctx.fillStyle = "#FFFFFF";
                        ctx.fillText(icons[type], 12, yOffset + 2);

                        // Draw progress bar
                        const barWidth = 80;
                        const barHeight = 4;
                        const barX = 40;
                        const barY = yOffset + iconSize - 2;

                        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        const colors = {
                            speed: "#FFD700",
                            shield: "#00BFFF",
                            rainbow: "#FF1493",
                        };

                        ctx.fillStyle = colors[type];
                        ctx.fillRect(
                            barX,
                            barY,
                            barWidth * progress,
                            barHeight,
                        );

                        yOffset += iconSize + 8;
                    }
                }
            }

            // Initialize the game and load theme when DOM is ready
            document.addEventListener("DOMContentLoaded", () => {
                loadTheme();
                initMusic();
                render();
            });

            // Also initialize immediately in case DOM is already loaded
            if (document.readyState === "loading") {
                // DOM is still loading, wait for DOMContentLoaded
            } else {
                // DOM is already loaded
                loadTheme();
                initMusic();
                render();
            }
        </script>
    </body>
</html>
